#+title: Emacs Configuration
#+author: Ruijie Yu
#+property: header-args:emacs-lisp+ :exports code
#+property: header-args:emacs-lisp+ :tangle ~/.emacs.d/config.el
#+property: header-args:emacs-lisp+ :comments both
#+property: header-args:emacs-lisp+ :dir ~/.emacs.d
#+property: header-args:emacs-lisp+ :eval never-export
#+property: header-args:emacs-lisp+ :results none

* Preface

** Set up =init.el=
Making the configuration as a package fails -- too many errors occur
during compilation and on load. Hence here is my second attempt, now
to make a literate configuration using org-mode.

The configuration is heavily influenced by
[[https://config.daviwil.com/emacs]] and many pieces are taken either
verbatim or with minor tweaks to fit my particular workflow. In
addition, there are some other snippets taken from Q&A sites such as
SO, but unfortunately I do not recall where the snippets originated.

The following code block is for ="init.el"=, instructing =emacs= to
tangle and compile if necessary.
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
;;; -*- no-byte-compile: t -*-
;;; do not compile init.el

;; default dir at config folder
(setq-default default-directory (expand-file-name "~/.emacs.d"))

;; load the newer, not always .elc
(setq load-prefer-newer t)

;; redirect custom file so that customizations do not clutter
;; configuration file
(eval-and-compile
  (defconst defcustom-file
    (expand-file-name "~/.emacs.d/defcustom.el"))
  (when (file-exists-p defcustom-file)
    (load defcustom-file
          nil
          nil
          :nosuffix))
  
  (setq custom-file (expand-file-name "~/.emacs.d/custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file
	  nil				; noerror
	  nil				; nomessage
	  :nosuffix))
  )

;; check if need to tangle: emacs.org is newer than either *.el file
;; WARNING: this snippet *does not* reload "init.el" after a
;; successful tangling because of recursive loading. If "init.el" has
;; undergone significant changes, it is suggested to restart emacs for
;; the new init.el contents.
(let* ((this (expand-file-name "~/.emacs.d/emacs.org"))
       (init (expand-file-name "~/.emacs.d/init.el"))
       (config (expand-file-name "~/.emacs.d/config.el")))
  ;; when this file is newer than either *.el, re-tangle
  (when (or (file-newer-than-file-p this init)
	    (file-newer-than-file-p this config))
    (require 'ob-tangle)
    (declare-function org-babel-tangle-file load-file-name)
    (org-babel-tangle-file this))

  ;; now that the files are re-tangled, try to re-compile and load
  ;; them
  (require 'bytecomp)
  (dolist (file (list init config))
    (byte-recompile-file
     file
     nil				; only recompile older
     0					; compile if .elc absent
     (not (equal file init))
     ))
  )
#+end_src

** All custom variables
It seems that custom variables need to be declared first before being
able to be updated by =custom.el=, so here is a new file named
=defcustom.el= specifically for declaring the custom files. All
=defcustom= still belongs to their corresponding sections, but need to
be placed on a separate source block and redirect the tangle file to
=defcustom.el=.
#+begin_src emacs-lisp :tangle ~/.emacs.d/defcustom.el
;; -*- no-byte-compile: t -*-
#+end_src


* Enlarging GC
First, the garbage collection limit needs to raise a lot when =emacs=
starts up. NOTE: this raises the GC limit to *4GiB*.
#+begin_src emacs-lisp
(setq gc-cons-threshold
      (* 4 1024 1024 1024))
(add-hook
 'emacs-startup-hook
 (lambda ()
   (message "** Emacs loaded in %s with %d GCs."
	    (format "%.2fs"
		    (float-time
		     (time-subtract
		      after-init-time
		      before-init-time)))
	    gcs-done)))
#+end_src

* Package Management
:properties:

:end:
Currently I am using =package.el= with =use-package=, but I may take a look at
=straight.el= in the future when I don't need to stress on schoolwork as much.

Reference: [[https://emacs.stackexchange.com/a/50603]]

First make sure melpa is available, which hosts most packages that I need.
#+begin_src emacs-lisp
(require 'package)
(eval-and-compile
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/")))
#+end_src

Then initialize package database. Force refresh contents during compilation.
#+begin_src emacs-lisp
(eval-when-compile
  (package-initialize)
  (package-refresh-contents))
#+end_src

Then make sure =use-package= is installed.
#+begin_src emacs-lisp
(eval-and-compile
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  ;; not sure why, but this is only needed during byte compilation
  (require 'use-package)
  (require 'bind-key)
  )
#+end_src

* Keybind Setup
I use a combination of =general.el=, =hydra= and =:bind= from =use-package= to configure
keybinds. I /might/ make them uniform in the future but not now.

** Personal Keybindings
It appears that for some reason the variable =personal-keybindings=
needs to be defined. For now, I assume =use-package= uses =bind-key= to
add keybindings.

#+begin_src emacs-lisp
(use-package bind-key
  :ensure t
  )
#+end_src

** Initializing =general.el=
#+begin_src emacs-lisp
(eval-and-compile
  (use-package general
    :ensure t
    :config
    (general-create-definer
      cfg-keybind--leader
      :prefix "<C-tab>"
      )
    (general-create-definer
      cfg-keybind--C-c
      :prefix "<C-c>"
      )
    )
  )
#+end_src

** Initializing =hydra=
The =hydra= package is for transient keybindings, where (as far as I understand)
the keybind is only activated when one runs a command generated by =defhydra=.

Currently the only place where =hydra= is used is in the text scaling
keybinds. They could either be expanded, or be replaced completely.
#+begin_src emacs-lisp
(use-package hydra
  ;; just make sure the package is installed
  :ensure t
  :config
  (declare-function hydra--call-interactively-remap-maybe load-file-name)
  (declare-function hydra-default-pre load-file-name)
  (declare-function hydra-keyboard-quit load-file-name)
  (declare-function hydra-set-transient-map load-file-name)
  (declare-function hydra-show-hint load-file-name)
  (declare-function hydra-timeout load-file-name)
  )
#+end_src

* Visual Overhaul
This section presents several overhauls to =emacs=.

** Icons
This part loads the =all-the-icons= package, and if necessary, installs all
relavent fonts (download from [[github.com]]). One caveat: when running in daemon
mode, =display-graphic-p= will return =nil= and may erronously avoid installation of
the fonts even when they are missing.

To remedy this issue, one could propose removing the GUI condition. However,
with this condition removed =find-font= is unable to locate any fonts without a
GUI frame, which means the fonts is installed every time a daemon starts,
regardless of whether they are already present on the system.

All I need is something that detects fonts even without GUI.
#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t
  :config
  (when (and (display-graphic-p)
	     (not (find-font (font-spec
			      :name "all-the-icons"))))
    (all-the-icons-install-fonts t))
  )
#+end_src

** Modeline
Doom modeline with a few customizations.
#+begin_src emacs-lisp
(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1)
  ;; :custom-face
  ;; (mode-line ((t (:height .85))))
  ;; (mode-line-inactive ((t (:height .85))))
  :hook (after-init . doom-modeline-mode)
  :custom
  ;; ref: https://github.com/seagle0128/doom-modeline under readme
  ;; sizes
  (doom-modeline-height 12)
  (doom-modeline-bar-width 6)
  ;; icons
  (doom-modeline-icon (display-graphic-p)) ; only gui
  ;; major modes
  (doom-modeline-major-mode-icon t)
  (doom-modeline-major-mode-color-icon t)
  ;; minor modes
  (doom-modeline-minor-modes t)		; whether to show
  ;; misc
  (doom-modeline-enable-word-count nil)
  (doom-modeline-mu4e nil)
  )
#+end_src

** Theme
This section configures themes and a keybind for when I regret my previous
decision on themes.

Also, the fact that themes are applied indiscriminantly in GUI and terminal
means that my workflow may need some changes. In particular, I probably need
either to somehow combine two themes together to apply separately in GUI and
terminal, or to just use two separate daemons. However, there are certain parts
of the configuration spawn external processes which may be fighting over each
other for exclusive resources such as sockets and locks.
#+begin_src emacs-lisp
;; use built-in function as a "backup" function for counsel's load-theme
(defalias 'counsel-load-theme #'load-theme)
(cfg-keybind--leader
  "t" '(:ignore t :which-key "theme")
  "tt" '(counsel-load-theme
	 :which-key "select theme"))

;; load doom themes
(use-package doom-themes
  :ensure t
  :custom
  (doom-themes-enable-bold t)
  (doom-themes-enable-italic t)
  :config
  (load-theme 'doom-gruvbox t)
  ;; TODO need to read up the use cases
  (doom-themes-neotree-config)
  (doom-themes-org-config)
  )
#+end_src

** Dimisish
Hide certain minor modes from modeline.
#+begin_src emacs-lisp
(use-package diminish
  :ensure t
  )
#+end_src

* Dired

** Dired
#+begin_src emacs-lisp
;; dired-omit-mode is bound to <C-x><M-o> in dired
(use-package dired-x
  :ensure nil
  :after (dired rx)
  :preface (require 'rx)
  :hook
  (dired-mode . dired-omit-mode)
  ;; hide-details-mode is bound to "(" in dired-mode
  :custom
  ;; dired-omit-extensions alredy contains "~" and "elc"
  (dired-omit-files
   (rx (or (seq string-start ".." string-end)
	   ;; (seq ?~ string-end)
	   (seq string-start ".#")
	   )))
  (dired-omit-verbose nil)	  
  )

(use-package dired
  :ensure nil
  :custom
  (dired-listing-switches
   (concat "--all "
	   "--human-readable "
	   "-go " ; like -l, -g omits group, -o omits user
	   "--group-directories-first "))
  (delete-by-moving-to-trash t)
  (dired-ls-F-marks-symlinks t)
  )
#+end_src

** Dired with Icons
#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :ensure t
  :if (display-graphic-p)
  :requires all-the-icons
  :hook
  (dired-mode . (lambda () (when (display-graphic-p)
			     (all-the-icons-dired-mode))))
  )
#+end_src

* PDF
#+begin_src emacs-lisp
(use-package pdf-tools
  :ensure t
  :defer 10
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :commands pdf-view-mode
  :hook
  (pdf-view-mode . auto-revert-mode)
  :config
  ;; I think `pdf-tools-install' will check whether installation is
  ;; necessary
  (pdf-tools-install :no-query)
  )
#+end_src

* Python
#+begin_src emacs-lisp
(use-package jupyter
  :ensure t
  :if (executable-find "jupyter")
  :after (org
	  python)
  :custom
  (org-babel-default-header-args:jupyter-python
   '((:async . "yes")
     (:kernel . "python3")
     (:eval . "never-export")
     (:exports . "both")
     ))
  :defines org-babel-load-languages
  :config
  (dolist (lang '((python . t)
		  (jupyter . t)))
    (add-to-list 'org-babel-load-languages lang))
  (org-babel-do-load-languages
   'org-babel-load-languages
   org-babel-load-languages)
  )

(use-package python
  :ensure nil
  )

(use-package yapfify
  :ensure t
  :diminish yapf-mode
  :hook (python-mode . yapf-mode)
  )
#+end_src

* Org
Orgmode configurations.
#+begin_src emacs-lisp
;; (declare-function org-insert-structure-template load-file-name)
(use-package org
  :ensure t
  :diminish
  (ispell-minor-mode
   auto-fill-mode
   org-indent-mode
   org-num-mode)
  :hook
  (org-mode . org-num-mode)
  (org-mode . auto-fill-mode)
  ;; (org-mode . visual-line-mode)
  (org-mode . ispell-minor-mode)
  (org-mode . org-indent-mode)
  ;; :functions org-insert-structure-template
  :bind
  (:map org-mode-map
	("<C-->" . #'org-insert-structure-template)
	)
  :custom
  (org-src-preserve-indentation t)
  (org-ellipsis " ▾")
  (org-hide-emphasis-markers t)
  (org-src-fontify-natively t)
  (org-fontify-quote-and-verse-blocks t)
  (org-src-tab-acts-natively t)
  ;; (org-edit-src-content-indentation 2)
  (org-hide-block-startup nil)
  (org-startup-folded 'content)
  (org-cycle-separator-lines 2)

  :config
  (declare-function org-insert-structure-template load-file-name)
  ;; show bullet points as unicode
  (font-lock-add-keywords
   'org-mode
   '(("^ +\\([-*]\\) "
      (0
       (prog1 ()
	 (compose-region
	  (match-beginning 1)
	  (match-end 1)
	  "•"))))))
  )

;; allow markdown export
(use-package ox-md
  :ensure nil
  :requires org
  )

;; auto-show latex snippet
(use-package org-fragtog
  :ensure t
  :diminish
  :hook
  (org-mode . org-fragtog-mode)
  )

;; auto-show markup symbols
(use-package org-appear
  :ensure t
  :diminish
  :hook
  (org-mode . org-appear-mode)
  )

;; src block templates
(use-package org-tempo
  :ensure nil
  :after org
  :config
  (dolist (pair '(("sh" . "sh")
		  ("el" . "emacs-lisp")
		  ("py" . "python")
                  ("md" . "markdown")
		  ;; ("jp" . "jupyter-python")
		  ))
    ;; use `add-to-list' because it treats the list as a set
    (add-to-list 'org-structure-template-alist
		 (cons (car pair)
		       (concat "src " (cdr pair))))
    )
  )
#+end_src

** =calc= integration in =org=
#+begin_src emacs-lisp
(use-package calc-frac
  :ensure nil
  :after calc
  :custom
  (calc-frac-format '("/" nil))
 )

(use-package calc
  :ensure nil
  :after org
  :custom
  (calc-prefer-frac t)
  (calc-display-working-message t)
  )
#+end_src

* CPP
#+begin_src emacs-lisp :tangle ~/.emacs.d/defcustom.el
(defcustom cfg-path--clang-format
  (expand-file-name "~/.emacs.d/clang-format")
  "The path to the *.el files for clang-format."
  :type 'directory
  :group 'custom
  )
#+end_src

#+begin_src emacs-lisp
(eval-and-compile
  ;; can't find a way to disable undefined functions warning
  (push cfg-path--clang-format load-path)
  )

(use-package clang-format
  :ensure nil ; provided by arch "clang"
  :if (file-exists-p cfg-path--clang-format)
  :functions (clang-format
              clang-format-buffer
              clang-format-region)
  :bind
  ("<C-c>fb" . #'clang-format-buffer)
  ("<C-c>ff" . #'clang-format)
  ("<C-c>fr" . #'clang-format-region)
  )
#+end_src

* Text Modes
Some helpful packages and keybindings useful in pure text contexts.

** Auto Visual-Line for Text Files
#+begin_src emacs-lisp
(use-package text-mode
  :ensure nil
  :hook (text-mode . visual-line-mode)
  )
#+end_src

** Unfill Text
Unfill a text region when under visual line mode
#+begin_src emacs-lisp
(use-package unfill
  :ensure t
  :after simple
  :bind
  ("<C-c>q" . unfill-paragraph)
  (:map visual-line-mode-map
        ("<C-M-q>" . unfill-paragraph)
        )
  )
#+end_src

* Terminal Modes
** term
#+begin_src emacs-lisp
(use-package eterm-256color
  :ensure t
  :hook (term-mode . eterm-256color-mode)
  )

(use-package term
  :ensure nil
  :commands (term
	     new-term)
  :custom
  (explicit-shell-file-name "zsh")
  (explicit-zsh-args nil)
  :functions (term-check-proc
              term-mode
              term-exec
              term-char-mode
              cfg-term--buffer-usable
              cfg-term--next
              cfg-term--make)
  :config
  (defun cfg-term--buffer-usable (buffer-or-name)
    ;; a buffer is usable if any of these are true:
    ;; 1. it does not exist;
    ;; 2. it exists but the terminal is "dead"
    ;;
    ;; return the buffer if it is usable, otherwise nil
    (let ((buffer (get-buffer-create buffer-or-name)))
      (if (not (term-check-proc buffer))
          buffer))
    )

  (defun cfg-term--next (name &optional index)
    "Get the first usable terminal buffer.
Check whether the buffer \"*NAME*<INDEX>\" is usable as a
terminal. Iterate index until the first usable buffer and return
this usable buffer."
    (let* ((index (or index 0))
	   (buffer-name
	    (concat "*" name "*<"
		    (number-to-string index)
		    ">"))
           (buffer-or-nil
	    (cfg-term--buffer-usable buffer-name)))
      (or buffer-or-nil
          (cfg-term--next name (+ index 1))))
    )

  (defun cfg-term--make (name
			 program
			 &optional startfile
			 &rest switches)
    "Make a term process NAME in a buffer, running PROGRAM.
The name of the buffer is verbatim to the argument NAME.
Optional third arg STARTFILE is the name of a file to send the
contents of to the process.  Any more args (SWITCHES) are
arguments to PROGRAM."
    (let ((buffer (cfg-term--next name)))
      ;; If no process, or nuked process, crank up a new one and put
      ;; buffer in term mode.  Otherwise, leave buffer and existing
      ;; process alone.
      (cond ((not (term-check-proc buffer))
	     (with-current-buffer buffer
	       (term-mode)) ; Install local vars, mode, keymap, ...
	     (term-exec buffer name program startfile switches)))
      buffer)
    )

  ;; create a new terminal
  (defun new-term (program)
    "Start a terminal-emulator with PROGRAM in a new, indexed buffer.
The buffer is in Term mode; see `term-mode' for the commands to
use in that buffer.  Also see `term' and `make-term'."
    
    (interactive
     (list
      (read-from-minibuffer
       "Run program: "
       (or explicit-shell-file-name
	   (getenv "ESHELL")
	   shell-file-name))))

    (let ((buffer (cfg-term--make "terminal" program)))
      (set-buffer buffer)
      (term-mode)
      (term-char-mode)
      (switch-to-buffer buffer))
    )
  )
#+end_src

** vterm
#+begin_src emacs-lisp
(use-package vterm
  :ensure t
  :if (executable-find "cmake")
  :commands vterm
  :custom
  (vterm-shell "zsh")
  (vterm-max-scrollback 10000)
  )
#+end_src

** eshell
#+begin_src emacs-lisp
(use-package eshell-git-prompt
  :ensure t
  :after eshell
  :config
  (eshell-git-prompt-use-theme 'powerline)
  )

(use-package esh-opt
  :ensure nil
  :custom
  (eshell-destroy-buffer-when-process-dies t)
  (eshell-visual-commands
   '("htop" "btop"
     "bash" "zsh" "fish"
     "vim" "less" "more" "man"))
  )

(use-package esh-mode
  :ensure nil
  :config
  (declare-function eshell-truncate-buffer ())
  )

(use-package eshell
  :ensure nil
  :requires (esh-mode
	     esh-opt)
  :commands eshell
  :hook
  (eshell-pre-command . eshell-save-some-history)
  (eshell-first-time-mode
   . (lambda ()
       (push #'eshell-truncate-buffer
	     eshell-output-filter-functions)))
  (eshell-mode
   . (lambda () (display-line-numbers-mode -1)))
  :custom
  (eshell-history-size 10000)
  (eshell-buffer-maximum-lines 10000)
  (eshell-hist-ignoredups t)
  (eshell-scroll-to-bottom-on-input t)
  :config
  (cfg-keybind--leader
    "<RET>" #'eshell
    "<C-return>" #'eshell
    )
  )

(use-package eshell-syntax-highlighting
  :ensure t
  :after esh-mode
  :config
  (eshell-syntax-highlighting-global-mode)
  )
#+end_src

** shell in orgmode
#+begin_src emacs-lisp
(with-eval-after-load 'org
  (dolist (lang '((shell . t)
                  ))
    (add-to-list 'org-babel-load-languages lang))
  (org-babel-do-load-languages
   'org-babel-load-languages
   org-babel-load-languages)
  )
#+end_src

* Utilities 
** =which-key=
Memories fail. Sometimes I need reminders on what keys correspond to what
commands.
#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :requires diminish
  :demand t
  :diminish which-key-mode
  :custom
  (which-key-idle-delay 1)
  :config
  (which-key-mode)
  )
#+end_src

** =helpful= to be helpful
In the same vein, I need to look up commands, variables and various other
topics.
#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :after counsel
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key)
  )
#+end_src

** =swiper= to enhance searching
The package =swiper= provides direct visual feedback to searches.
#+begin_src emacs-lisp
(use-package swiper
  :ensure t
  :commands (swiper
	     swiper-backward)
  :bind
  ([remap isearch-forward] . swiper)
  ([remap isearch-backward] . swiper-backward)
  )
#+end_src

** Completion Framework
#+begin_src emacs-lisp
;; completion framework
(use-package vertico
  :ensure t
  :custom
  (vertico-cycle t) ; <up> for last entry
  :config
  (vertico-mode)
  )

;; additional information
(use-package marginalia
  :ensure t
  :bind
  (:map minibuffer-local-map
	("<M-a>" . marginalia-cycle)
	)
  :init (marginalia-mode)
  )
#+end_src

** Window Selection
This package allows to press =<M-o>= to switch to a different buffer (on the same
frame). Similar to qutebrowser's =f= key.
#+begin_src emacs-lisp
;; allow to select buffers based on a set of keys
(use-package ace-window
  :ensure t
  :bind
  ("<M-o>" . ace-window)
  :custom
  (aw-scope 'frame)
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-minibuffer-flag t)
  :config
  (ace-window-display-mode)
  )
#+end_src

** Region Selection
#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
  :bind
  ("<M-[>" . er/expand-region)
  ("<M-]>" . er/contract-region)
  ;; the following does not work in tty
  ("<C-(>" . er/mark-outside-pairs)
  ("<C-)>" . er/mark-inside-pairs)
  )
#+end_src

** =magit= for git vbs
#+begin_src emacs-lisp
(use-package magit
  :ensure t
  )
#+end_src

** snippets
#+begin_src emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :hook (prog-mode . yas-minor-mode)
  :config
  (declare-function yas-reload-all load-file-name)
  (yas-reload-all)
  )
#+end_src

** rainbow delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode)
  )
#+end_src

** =ediff=
Interactive =diff='ing.
#+begin_src emacs-lisp
(use-package ediff
  :ensure nil
  :commands (ediff
	     ediff-files)
  :custom
  (ediff-diff-options "-w")
  (ediff-swplit-window-function
   #'split-window-horizontally)
  (ediff-window-setup-function
   #'ediff-setup-windows-plain)
  )
#+end_src

** No mouse
Disable mouse on GUI.
#+begin_src emacs-lisp
(use-package disable-mouse
  :ensure t
  :config
  (declare-function global-disable-mouse-mode load-file-name)
  (global-disable-mouse-mode)
  )
#+end_src

** IM
#+begin_src emacs-lisp
;; well, fcitx never worked and now I am on wayland
(use-package pyim
  :ensure t
  :bind
  ("<M-j>" . pyim-convert-string-at-point)
  :custom
  (pyim-english-input-switch-functions
   '(pyim-probe-dynamic-english
     pyim-probeprogram-mode))
  ;; half-width punctuations
  (pyim-punctuation-half-width-functions
   '(pyim-probe-punctuation-line-beginning
     pyim-probe-punctuation-after-punctuation))
  ;; popup?
  (pyim-page-tooltip 'popup)
  ;; probably don't need other input methods (other than latex and
  ;; greek?)
  (default-input-method "pyim")
  )
#+end_src

* Linting
Use =flycheck= for file linting.
#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :diminish global-flycheck-mode
  :custom
  (flycheck-keymap-prefix (kbd "<C-tab>f"))
  :hook (after-init . global-flycheck-mode)
  )

(use-package flycheck-pycheckers
  :ensure t
  :after flycheck
  :hook
  (flycheck-mode . flycheck-pycheckers-setup)
  )
#+end_src

* Security
#+begin_src emacs-lisp
;; I use pass
(use-package password-store
  :ensure t
  :custom
  ;; something doesn't accept >30 today
  (password-store-password-length 30)
  )
(use-package password-store-otp
  :ensure t
  :requires password-store
  )
(use-package auth-source-pass
  :ensure nil
  :config
  (auth-source-pass-enable)
  )

(use-package pinentry
  :ensure t
  :custom
  (epg-pinentry-mode 'loopback)
  :config
  ;; this is undocumented, but shown in code: only start pinentry if
  ;; not already done so
  (unless (process-live-p pinentry--server-process)
    (pinentry-start))
  )
#+end_src

* General Configuration
There are a few miscellaneous configurations that are too small to fit in their
own sections.

** Default Encoding
#+begin_src emacs-lisp
(set-default-coding-systems 'utf-8)
#+end_src

** Scrolling
The following two keybinds allow to scroll the buffer with the cursor.
#+begin_src emacs-lisp
(global-set-key
 (kbd "<M-n>")
 (kbd "<C-u>1 <C-v>"))
(global-set-key
 (kbd "<M-p>")
 (kbd "<C-u>1 <M-v>"))
#+end_src

** Color Inversion
This keybind inverts colors. Unfortunately, buffers containing images such as
PDF buffers are largely unaffected. In addition, the keybind does not work in
tty, but tty can't have color inversion anyways so things should be fine.
#+begin_src emacs-lisp
(global-set-key
 (kbd "<C-=>")
 (lambda () (interactive) (invert-face 'default)))
#+end_src

** UI Minimization
A few tweaks to minimize the UI.
#+begin_src emacs-lisp
(setq
 inhibit-startup-message t		; thanks but see you no more
 mouse-wheel-scroll-amount '(1 ((shift) . 1)) ; scroll one line each time
 mouse-wheel-progressive-speed nil ; don't accelerate scrolling
 mouse-wheel-follow-mouse t
 scroll-step 1				; keyboard scrolling
 use-dialog-box nil
 large-file-warning-threshold nil	; I know what I'm doing
 vc-follow-symlinks t			; don't ask
 )

(setq-default
 full-column 80				; short lines
 indent-tabs-mode nil			; no tabs
 )

(add-hook 'makefile-mode-hook
	  (lambda () (setq-local indent-tabs-mode 'only)))

(defun cfg-ui-minimize ()
  "Minimize the UI."
  (interactive)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1) ; show tooltip in minibuffer instead of pop-up window
  (menu-bar-mode -1)
  (column-number-mode 1)
  )

(cfg-ui-minimize)

(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

** Text Scaling
This section uses =hydra= to scale text.
#+begin_src emacs-lisp
(with-eval-after-load 'hydra
  (defhydra cfg--text-scale (:timeout 5)
    "text scaling"
    ("j" text-scale-increase "enlarge")
    ("k" text-scale-decrease "shrink")
    ("<RET>" nil "finish" :exit t)
    ("f" nil "finish" :exit t)
    ("q" nil "finish" :exit t)
    )
  (cfg-keybind--leader
    "s" '(cfg--text-scale/body
          :which-key "text-scaling")
    )
  )
#+end_src

Also, set default scaling.
#+begin_src emacs-lisp
(use-package default-text-scale
  :ensure t
  :config
  (default-text-scale-mode)
  )
#+end_src

** Auto Reload Files
#+begin_src emacs-lisp
(use-package autorevert
  :ensure nil
  :custom
  (global-auto-revert-non-file-buffers nil)
  :config
  (global-auto-revert-mode)
  )
#+end_src

** Tramp
Using =tramp= for remote file editing and computing.
#+begin_export emacs-lisp
(use-package tramp
  :ensure nil
  :custom
  ;; this uses ssh v2, where "ssh" uses v1
  ;; default "scp", maybe need investigation
  (tramp-default-method "sshx")
  )
#+end_export

** Inferior Editing Sessions

Modify the environment variables =EDITOR= and =VISUAL= so that when inferior
processes try to launch an editor to just use the existing frame / window.
#+begin_src emacs-lisp
(when (and (featurep 'server)
           server-process)
  (setenv "EDITOR" "emacsclient")
  (setenv "VISUAL" "emacsclient")
  )
#+end_src

** llvm
#+begin_src emacs-lisp :tangle ~/.emacs.d/defcustom.el
(defcustom cfg-path--llvm-mode
  (expand-file-name "~/.emacs.d/llvm-mode")
  "Path to LLVM-mode files."
  :type 'directory
  :group 'custom
  )
#+end_src

#+begin_src emacs-lisp
(eval-and-compile
  (push cfg-path--llvm-mode load-path)
  )

(use-package llvm-mode
  ;; installed in AUR as emacs-llvm-mode
  :ensure nil
  :if (file-exists-p cfg-path--llvm-mode)
  :mode
  ("\\.ll\\'" . llvm-mode)
  )
#+end_src

* Registers
Add a few personal registers for easy accessibility.
#+begin_src emacs-lisp
(dolist (file-register '((?e . "~/.emacs.d/emacs.org")
                         ))
  (set-register (car file-register)
                `(file . ,(cdr file-register))))

;; additional registers can be set under ~/.emacs.d/registers.el
(let ((fname (expand-file-name "~/.emacs.d/registers.el")))
  (when (file-exists-p fname)
    (load fname nil nil :nosuffix)))
#+end_src

* Finishing Up
Lastly, the garbage collection limit is tuned down to a saner value, but still
higher than the default value from =emacs=.
#+begin_src emacs-lisp
(setq gc-cons-percentage
      (* 2 1024 1024))
#+end_src
